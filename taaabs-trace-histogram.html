<!-- paper dependencies -->
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<!-- google dependencies -->
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="../google-chart/google-chart.html">
<!-- taaabs dependencies -->
<link rel="import" href="../notify-toast-behavior/notify-toast-behavior.html">
<link rel="import" href="../taaabs-time-utilities/taaabs-time-utilities.html">
<link rel="import" href="../taaabs-themes/taaabs-theme.html">
<link rel="import" href="./taaabs-trace-histogram-lite.html">

<dom-module id="taaabs-trace-histogram">
  <template>
    <style include="taaabs-theme"></style>
    <style>
      :host {
        display: block;
      }

      .chartSettingsDiv{
        padding: 5px;
      }

      #spinnerContainer{
        position: relative;
        margin-top: -300px;
        left: 0;
        width: 100%;
        height: 300px;
        background-color: rgba(0,0,0,0.37);
        display: none;
      }

      #spinnerContainer paper-spinner{
        position: relative;
        top: 50%;
        left: 50%;
        margin-top: -50px;
        margin-left: -50px;
        height: 100px;
        width: 100px;
      }

      /*
      Breadcrumbs
      Source: https://css-tricks.com/triangle-breadcrumbs/
      */

      .breadcrumb {
        list-style: none;
        overflow: hidden;
        font-size: 12px;
        padding: 0px;
        margin: 0px;
      }

      .breadcrumb li {
        float: left;
      }

      .breadcrumb li div {
        color: black;
        text-decoration: none;
        text-align: center;
        padding: 10px 0 10px 65px;
        position: relative;
        display: block;
        float: left;
        -webkit-transition: background-color 0.25s ease-in-out;
        transition: background-color 0.25s ease-in-out;
        background-color: var(--paper-grey-50);
        cursor: pointer;
      }

      .breadcrumb li div::after {
        content: " ";
        display: block;
        width: 0;
        height: 0;
        border-top: 50px solid transparent; /* Go big on the size, and let overflow hide */
        border-bottom: 50px solid transparent;
        border-left: 30px solid var(--paper-grey-50);
        position: absolute;
        top: 50%;
        margin-top: -50px;
        left: 100%;
        z-index: 2;
        -webkit-transition: border 0.25s ease-in-out;
        transition: border 0.25s ease-in-out;
      }

      .breadcrumb li div::before {
        content: " ";
        display: block;
        width: 0;
        height: 0;
        border-top: 50px solid transparent;
        border-bottom: 50px solid transparent;
        border-left: 30px solid white;
        position: absolute;
        top: 50%;
        margin-top: -50px;
        margin-left: 1px;
        left: 100%;
        z-index: 1;
      }

      .breadcrumb li:first-child div {
        padding-left: 10px;
      }
      .breadcrumb li:nth-child(2n+1) div       { background-color:  var(--paper-grey-100); }
      .breadcrumb li:nth-child(2n+1) div:after { border-left-color: var(--paper-grey-100); }

      .breadcrumb li div:hover {
        background-color: var(--paper-grey-200);
      }
      .breadcrumb li div:hover:after {
        border-left-color: var(--paper-grey-200) !important;
      }

    </style>

    <div class="flex-vertical">
      <div class="chartSettingsContainer flex-horizontal">
        <div class="chartSettingsDiv flexchild">
          <paper-dropdown-menu id="groupBySelect" label="{{localize('groupBy')}}" disabled noink>
            <paper-listbox class="dropdown-content" selected="{{_groupByIndex}}">
              <paper-item value="-group-by-type-">-group-by-type-</paper-item>
              <template is="dom-repeat" items="{{_attributesList}}">
                <paper-item value="{{item}}">{{item.name}}</paper-item>
              </template>
  </paper-listbox>
  </paper-dropdown-menu>
  </div>
  <div class="chartSettingsDiv flexchild">
    <paper-dropdown-menu label="{{localize('interval')}}" noink id="period-index-dropdown">
      <paper-listbox class="dropdown-content" selected="{{_periodIndex}}">
        <paper-item value="custom-period">Custom period number</paper-item>
        <paper-item value="millisecond">Millisecond</paper-item>
        <paper-item value="second">Second</paper-item>
        <paper-item value="minute">Minute</paper-item>
        <paper-item value="hour">Hour</paper-item>
        <paper-item value="half-day">Half-Day</paper-item>
        <paper-item value="day">Day</paper-item>
        <paper-item value="week">Week</paper-item>
        <paper-item value="month">Month</paper-item>
        <paper-item value="year">Year</paper-item>
      </paper-listbox>
    </paper-dropdown-menu>
  </div>
  <div class="chartSettingsDiv" style="width: 80px">
    <paper-input type="Number" value="10" min="0" label="{{localize('customPeriodNumber')}}" disabled id="customPeriodInput"></paper-input>
  </div>
  <div class="chartSettingsDiv flexchild">
    <paper-dropdown-menu label="{{localize('offset')}}" disabled>
      <paper-listbox id="offsetListbox" class="dropdown-content">
      </paper-listbox>
    </paper-dropdown-menu>
  </div>
  <div class="chartSettingsDiv" style="width: 80px">
    <paper-input type="Number" value="10" min="0" label="{{localize('customPeriodNumber')}}" disabled></paper-input>
  </div>
  <div class="chartSettingsDiv flexchild" style="padding-top: 14px">
    <div class="flex-equal-around-justified">
      <paper-button id="applyBtn" on-click="_onApplyClick" raised noink>{{localize('apply')}}</paper-button>
    </div>
  </div>
  <div class="chartSettingsDiv flex-reversed flexchild" style="padding-top: 34px">
    <div>
      <paper-checkbox id="durationCheck"  on-click="_onDurationClick"  noink title="[[localize('duration-title')]]">{{localize('duration')}}</paper-checkbox>
      <paper-checkbox id="normalizeCheck" on-click="_onNormalizeClick" noink>{{localize('normalize')}}</paper-checkbox>
    </div>
  </div>
  <div class="chartSettingsDiv flex-reversed flexchild" style="padding-top: 14px">
    <div>
      <paper-button id="exportCSVBtn" on-click="_onExportCSVClick" raised noink>{{localize('exportcsv')}}</paper-button>
    </div>
  </div>
  </div>
  <div id="chart-container" style="border: solid 1px black; height: 500px;">
    <google-chart type='column' id="chart" options='{{chartOptions}}' style="width:100%; height: 100%" on-google-chart-select="_onChartClick">
    </google-chart>
    <div id="spinnerContainer">
      <paper-spinner id="spinner" active></paper-spinner>
    </div>
  </div>
  <div>
    <ul id="breadcrumbs-container" class="breadcrumb">
    </ul>
  </div>
  </div>

  <!-- Notify toast -->
  <paper-toast class="fit-bottom" id="__notify_toast__" style="background-color:rgba(0,0,0,0.37)" duration=0> </paper-toast>

  </template>
  <script>
    Polymer({

      /**
       * Fired when the taaabs-trace-histogram send a sparql-query.
       *
       * @event loading-sparql-query
       */

      is: 'taaabs-trace-histogram',

      properties: {

        /** ================================================================ **/
        /**  PUBLIC PROPERTIES                                               **/

        /**
         * The trace object.
         *
         * @attribute trace
         * @type Object
         */
        trace: {
          type: Object,
          notify: true,
          value: null
        },

        /**
         * The trace model.
         *
         * @attribute model
         * @type Object
         */
        model: {
         type: Object,
         notify: true,
         value: null
        },

        /**
         * The begin time (in ms from 01/01/1970) of the trace section.
         *
         * @attribute begin
         * @type Number
         */
        begin: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * The end time (in ms from 01/01/1970) of the trace section.
         *
         * @attribute end
         * @type Number
         */
        end: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * One constraint object [ATTRIBUTE_NAME, ATTRIBUTE_VALUE].
         *
         * @attribute constraint
         * @type Array
         */
        constraint: {
          type: Array,
          notify: true,
          value: []
        },

        /**
         * The options of the chart.
         *
         * @attribute chartOptions
         * @type Object
         */
        chartOptions: {
          type: Object,
          notify: true,
          value: function() {
            return {
              "isStacked": true,
              "focusTarget": "category",
              "animation": {
                "duration": 500,
                "easing": "inAndOut"
              },
              "legend": {
                "position": "right"
              }
            };
          }
        },

        //
        // "vAxis": {
        //    "ticks": [{v:0, f:"0:00.0"}, {v:2500000, f:"0:42.0"}, {v:5000000, f:"1:38:0"}]
        //  }

        /**
         * True if the taaabs-trace-histogram is loading a sparql query. False otherwise.
         *
         * @attribute isLoading
         * @type Boolean
         */
        isLoading: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * List of the offsprings of the `trace-histogram`.
         *
         * @attribute offsprings
         * @type Array
         */
        offsprings: {
          type: Array,
          notify: true,
          value: []
        },

        /** ================================================================ **/
        /**  PRIVATE PROPERTIES                                              **/

        /**
         * List of the obsel attributes of the trace.
         *
         * @attribute _attributesList
         * @type Array
         */
        _attributesList: {
          type: Array,
          notify: true,
          value: []
        },

        /**
         * A taaabs-time-utilities.
         *
         * @attribute _ttu
         * @type Object
         */
        _ttu: {
          type: Object,
          notify: true,
          value: function() {
            return new TAAABS.TimeUtilities();
          }
        },

        /**
         * The raw datas of the sparql query.
         *
         * @attribute _queryResponseDatas
         * @type Object
         */
        _queryResponseDatas: {
          type: Object,
          notify: true,
          value: null
        },

        /**
         * The index of the groupby select.
         *
         * @attribute _groupByIndex
         * @type Number
         */
        _groupByIndex: {
          type: Number,
          notify: true,
          value: 0
        },

        _colors: {
          type: Array,
          notify: true,
          value: function() {
            return ['#3366CC', '#DC3912', '#FF9900', '#109618', '#990099', '#3B3EAC', '#0099C6',
              '#DD4477', '#66AA00', '#B82E2E', '#316395', '#994499', '#22AA99', '#AAAA11',
              '#6633CC', '#E67300', '#8B0707', '#329262', '#5574A6', '#3B3EAC'
            ];
          }
        },

        _colorsMap: {
          type: Object,
          notify: true,
          value: {}
        },

        /**
         * The period used selected.
         *
         * @attribute _periodIndex
         * @type Number
         */
        _periodIndex: {
          type: Number,
          notify: true,
          value: -1,
          observer: '_onPeriodIndexChange'
        },

        /**
         * List of the period indexes in the breadcrumb
         *
         * @attribute _breadcrumbPeriodIndex
         * @type Array
         */
        _breadcrumbPeriodIndex: {
          type: Array,
          notify: true,
          value: []
        },

        /**
         * The period - select index mapping.
         *
         * @attribute _periodMapping
         * @type Array
         */
        _periodMapping: {
          type: Array,
          notify: false,
          value: function() {
            return ['custom-period', 'millisecond', 'second', 'minute', 'hour',
              'half-day', 'day', 'week', 'month', 'year'
            ];
          }
        },

        /**
         * The number of interval we have in the timeline.
         *
         * @attribute _timeline_interval_count
         * @type Number
         */
        _timeline_interval_count: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * List of the different interval names.
         *
         * @attribute _timeline_interval_names
         * @type Array
         */
        _timeline_interval_names: {
          type: Array,
          notify: true,
          value: []
        },

        /**
         * Maximum value of a serie.
         *
         * @attribute _maxValue
         * @type Number
         */
        _maxValue: {
          type: Number,
          notify: true,
          value: Number.NEGATIVE_INFINITY
        },

        /**
         * Offsprings series.
         *
         * @attribute _offspringsDatas
         * @type Array
         */
        _offspringsDatas: {
          type: Array,
          notify: true,
          value: []
        },

        /**
         * Localization.
         * fr, en.
         *
         * @attribute language
         * @type String
         */
        language: {
          type: String,
          notify: true,
        },
      },

      behaviors: [
        Polymer.AppLocalizeBehavior,
        NotifyToastBehavior
      ],

      /** ================================================================== **/
      /**  INITIALIZATION                                                    **/

      /**
       *
       *
       @method attached
       **/
      attached: function() {
        // Load i18n json.
        this.loadResources(this.resolveUrl('./languages/locales.json'));
      },

      /**
       * Set `_attributeList` and fill the select.
       *
       * @param {!required} attributes {String} List of obsel attributes of the trace.
       *
       * @method setAttributesList
       */
      setAttributesList: function(attributes) {
        this.set('_attributesList', attributes);
        this.$.groupBySelect.disabled = false;
      },

      /**
       * Set `begin` & `end`, then fill the breadcrumbs.
       *
       * @param {!required} begin {Date} Begin date of the trace.
       * @param {!required} end {Date} End date of the trace.
       *
       * @method setBounds
       */
      setBounds: function(begin, end) {
        this.set('begin', begin);
        this.set('end', end);
        this._createBreadcrumb(begin, end);
      },

      /** ================================================================== **/
      /**  BREADCRUMBS                                                       **/

      /**
       * Create the breadcrumbs.
       *
       * @param {!required} begin {Date} Begin date of the breadcrumb.
       * @param {!required} end {Date} End date of the breadcrumb.
       *
       * @method _createBreadcrumb
       */
      _createBreadcrumb: function(begin, end) {
        // Create the DOM elements
        var bc = document.createElement('li');
        var bcd = document.createElement('div');
        // Fill the div with the human-readable date
        bcd.innerHTML = this._ttu.get_european_condensed_date(new Date(begin)) + '<br/>' + this._ttu.get_european_condensed_date(new Date(end));
        bc.appendChild(bcd);
        // Save the period index for rollback with the breadcrumb.
        var pi = JSON.parse(JSON.stringify(this._periodIndex));
        if (pi !== null) pi = pi + 1;
        this.push('_breadcrumbPeriodIndex', pi);
        // Add event on click : calls `_fallBackTo`
        bc.addEventListener('click', function(evt) {
          var elem = evt.target;
          this._fallBackTo(begin, end, elem);
        }.bind(this));
        // Add the breadcrumb.
        this.$['breadcrumbs-container'].appendChild(bc);
      },

      /**
       * Query the trace to set the histogram on the date and period of the selected breadcumb.
       *
       * @param {!required} begin {Number} The begin time.
       * @param {!required} end {Number} The end time.
       * @param {!required} elem {DOMElement} The clicked element.
       *
       * @method _fallBackTo
       */
      _fallBackTo: function(begin, end, elem) {
        // Set the begin and end time
        this.set('begin', begin);
        this.set('end', end);
        // Get the breadcrumb element (click event can occur en li or span)
        if (elem.tagName === "div" || elem.tagName === "DIV")
          elem = elem.parentNode;
        // Retrieve the period of the breadcrumb
        var period = null;
        var index = this._breadcrumbPeriodIndex.length - 1;
        while (this.$['breadcrumbs-container'].lastChild && this.$['breadcrumbs-container'].lastChild !== elem) {
          this.$['breadcrumbs-container'].removeChild(this.$['breadcrumbs-container'].lastChild);
          if (index >= 0 && this._breadcrumbPeriodIndex[index] !== null) {
            period = this.pop('_breadcrumbPeriodIndex');
            index--;
          }
        }
        // If the period exists, we can set the histogram with the new query.
        if (period) {
          this.set('_periodIndex', period);
          this._initLoadingStatus();
          this._setChart();
        }
      },

      /** ================================================================== **/
      /**  DOM LISTENERS                                                     **/

      /**
       * On `apply` button click. Load the datas form the trace according to the chart settings.
       *
       * @method _onApplyClick
       */
      _onApplyClick: function() {
        if (this._periodIndex >= 0) {
          this._initLoadingStatus();
          this._setChart();
        } else {
          this.notifyToast('You need to choose an interval first.', {
            'type': 'Log'
          });
        }
      },

      /**
       * On 'normalize' checkbox click. Normalize or not the chart.
       *
       * @method _onNormalizeClick
       */
      _onNormalizeClick: function() {
        if (this.$.normalizeCheck.checked) this.set('chartOptions.isStacked', 'percent');
        else this.set('chartOptions.isStacked', true);
      },

      /**
       * On 'hideLegend' checkbox click. Hide or not the legend of the chart.
       *
       * @method _onExportCSVClick
       */
      _onExportCSVClick: function() {
        var data = this.$.chart.data;
        var csvContent = "data:text/csv;charset=utf-8,";
        for(var j = 0 ; j < data.length; j++){
          dataString = "";
          var i = 0;
          for(i = 0 ; i < data[j].length - 1; i++){
            if(data[j][i] === null || data[j][i] === undefined){
              dataString += ',';
            }
            else{
              dataString += (data[j][i].indexOf && ( data[j][i].indexOf(',') !== -1 || data[j][i].indexOf('\n') !== -1)) ? '"'+data[j][i]+'",' : data[j][i]+',';
            }
          }
          if(data[j][i] !== null && data[j][i] !== undefined){
            dataString += (data[j][i].indexOf && (data[j][i].indexOf(',') !== -1 || data[j][i].indexOf('\n') !== -1)) ? '"'+data[j][i]+'"' : data[j][i];
          }
          csvContent += j < data.length ? dataString + "\n" : dataString;
        }
        var encodedUri = encodeURI(csvContent);
        var link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "my_data.csv");
        document.body.appendChild(link); // Required for FF
        link.click(); // This will download the data file named "my_data.csv".
        document.body.removeChild(link);
      },

      /**
       * On `_periodIndex` change. Check if the chosen period is the custom one.
       * In such case, allow the use of custom period input.
       *
       * @param {!required} evt {Event} The event object.
       *
       * @method _onPeriodIndexChange
       */
      _onPeriodIndexChange: function(evt) {
        if (evt !== -1 && this._periodMapping[evt] === 'custom-period') this.$.customPeriodInput.disabled = false;
        else this.$.customPeriodInput.disabled = true;
      },

      /**
       * Event launch when the user clicks on the chart.
       * Reload the histogram with a shorter timespan.
       *
       * @param {!required} e {Event} The event object.
       *
       * @method _onChartClick
       */
      _onChartClick: function(e) {
        if (this.$.chart.selection[0]) {
          var row = this.$.chart.selection[0].row + 1;
          this._ttu.resetIntervalRepeater();
          var i = 0;
          var result = null;
          while (i < row) {
            result = this._ttu.getNextIntervalUTC();
            i++;
          }
          this.$['chart-container'].style.opacity = '1';
          this.set('_periodIndex', this._periodIndex - 1);
          this.setBounds(result.begin.valueOf(), result.end.valueOf());
          this._initLoadingStatus();
          this._setChart();
        }
      },

      /** ================================================================== **/
      /**  LOADING                                                           **/

      /**
       * Init the loading status (DOM changes and event fire).
       *
       * @method _initLoadingStatus
       */
      _initLoadingStatus: function() {
        // Display the spinner
        this.$.spinner.active = true;
        this.$.spinnerContainer.style.display = 'block';
        // Disable the apply button
        this.$.applyBtn.disabled = true;
        // Set the loading status
        this.set('isLoading', true);
        this.fire('loading-sparql-query');
      },

      /**
       * Init the loading status (DOM changes and event fire).
       *
       * @method _endLoadingStatus
       */
      _endLoadingStatus: function() {
        // Display the spinner
        this.$.spinner.active = false;
        this.$.spinnerContainer.style.display = 'none';
        // Disable the apply button
        this.$.applyBtn.disabled = false;
        // Set the loading status
        this.set('isLoading', false);
      },

      /** ================================================================== **/
      /**  REQUEST                                                           **/

      /**
       * _createRequest :
       *    Duration   : t/f
       *    Offsprings : t/f
       *
       * _processRequestResults :
       *    Offsprings :
       *        _processRequestResultsForOffsprings
       *        _orderStackedDatas( _getSumOffspringsDatas )
       *        _setColors
       *        _setChartsTitle
       *        _fillCharts
       *    !Offsprings :
       *        _orderStackedDatas( _getStackedData );
       *        Duration :
       *            _fillChart( _applyDurationDisplay )
       *        !Duration :
       *            _fillChart
       *            Reset vAxis to default
       *    _endLoadingStatus
       *
      **/

      _getOffspringSubRequest: function(value, datatype){
        var borderDQ = /^".*"$/;
        // If the value is a string.
        if(datatype === ""){
          if(borderDQ.test(value)){
            value = value.substr(1, value.length - 2);
          }
          function getUni(char){
            var code = char.charCodeAt(0).toString(16);
            var res = code;
            for(var i = code.length; i < 4; i++){
              res = '0'+res;
            }
            res = '\\'+'u'+res;
            return res;
          }
          value = value.replace(/\W/g, getUni);
          return '("'+value+'")';
        }
        // If the value is anything else
        // TODO Check if we need any specific operation for any other type than string.
        else{
          return '("'+value+'"'+datatype+')';
        }
      },

      /**
       * Returns a sparql queries corresponding of the union of the counts of each obsel type in every interval of the trace.
       *
       * @param {!required} period {String} Period of time ('second', 'minute', 'hour', 'day', 'week', etc).
       *
       * @method _createRequest
       */
      _createRequest: function(period) {
        // Either we request on the type of obsel or the attributes.
        var type_sub_request = (this._groupByIndex === 0 || this._groupByIndex === -1)
                               ? "  ?o a ?type.\n"
                               : "  ?o m:" + this._attributesList[this._groupByIndex - 1].name + " ?type.\n";
        // If there are offsprings to fill ( basically more groups in the request)
        var constraint_sub_request = "";
        var offspring_var = "";
        var datatype = (this.constraint.datatype === "xsd:string") ? "" : "^^"+this.constraint.datatype;

        if (this.offsprings.length > 0) {
          offspring_var = "?ofs";
          constraint_sub_request = "  values (?ofs){";

          for (var i = 0; i < this.offsprings.length; i++) {
            constraint_sub_request += this._getOffspringSubRequest(this.offsprings[i][0], datatype);
          }
          constraint_sub_request += "}\n";
          constraint_sub_request += "  ?o m:" + this.constraint.name + " ?ofs.\n";
        }
        // If we request on the duration of obsels instead of the count.
        var duration_suffix = (this.$.durationCheck.checked) ? "BIND(?e-?b AS ?duration)\n" : "";
        var duration_prefix = (this.$.durationCheck.checked) ? "(SUM(?duration) as ?numMatches)" : "(COUNT(?o) as ?numMatches)";
        // The request "prefix" (i.e. the part before the intervals array)
        var request_prefix =
          "PREFIX : <http://liris.cnrs.fr/silex/2009/ktbs#>\n" +
          "PREFIX m: <" + this.trace.model_uri + "#>\n" +
          "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n"+
          "SELECT " + offspring_var + " ?rangeId "+duration_prefix+" ?type WHERE{\n" +
          "  values (?rangeId ?min ?max) {";
        // THe request suffix
        var request_suffix =
          "  }\n" +
          type_sub_request +
          constraint_sub_request +
          "  ?o :hasBegin ?b.\n" +
          "  ?o :hasEnd ?e.\n" +
          "  FILTER(?min <= ?e && ?e < ?max)\n" +
          duration_suffix +
          "}GROUP BY " + offspring_var + " ?rangeId ?type\n" +
          "ORDER BY " + offspring_var + " ?rangeId\n";
        // This function returns a part of the request where we count types between two temporal bounds.
        function _get_sub_request_(index, min, max) {
          return "(" + index + " " + min + " " + max + ")\n";
        }
        // We get the begin and end time of the trace.
        var beginTime = this.begin;
        var date = new Date(beginTime);
        var endTime = this.end;
        // We start the request.
        var request = request_prefix;
        // We init a counter. This one will gives us the number of sub request we create
        // i.e the number of interval we get from the request.
        var intervalCount = 0;
        // We "floor" the date.
        date = this._ttu.get_date_according_to_period(period, date);
        this._ttu.set('beginDate', date);
        this._ttu.set('interval', period);
        this._ttu.resetIntervalRepeater();
        // Result will define the bounds of every interval we create.
        var result = {
          'begin': date,
          'end': date
        };
        // If custom period is chosen.
        var customPeriodNumber = null;
        if (period === 'custom-period') {
          customPeriodNumber = Math.ceil((endTime - beginTime) / this.$.customPeriodInput.value);
        }
        this.set('_timeline_interval_names', []);
        // We create the intervals in a loop until we reach the end of the trace.
        while (result.end.valueOf() < endTime) {
          result = this._ttu.getNextIntervalUTC(customPeriodNumber);
          request += _get_sub_request_(intervalCount, result.begin.valueOf(), result.end.valueOf(), type_sub_request);
          this.push('_timeline_interval_names', this._ttu.get_human_readable_interval(result.begin, result.end, period));
          intervalCount++;
        }
        this.set('_timeline_interval_count', intervalCount);
        request += request_suffix;

        return request;
      },

      /**
       * Process the query results.
       *
       * @param {!required} rd {Array} The raw datas.
       *
       * @method _processRequestResults
       */
      _processRequestResults: function(rd) {
        // If the `taaabs-trace-histogram` is a simple histogram, we just fill the chart.
        // Otherwise, we fill each offspring
        if (this.offsprings.length > 0) {
          this._processRequestResultsForOffsprings(rd);
          this.$.chart.set('data', this._orderStackedDatas(this._getSumOffspringsDatas()));
          this._setColors();
          this._setChartsTitle();
          this._fillCharts();
        } else {
          var osd = this._orderStackedDatas(this._getStackedData(rd));
          if(this.$.durationCheck.checked){
            this._fillChart(this._applyDurationDisplay(osd));
            this._setTicks();
          }
          else{
            this._fillChart(osd);
            if( this.chartOptions.vAxis ) this.chartOptions.vAxis.ticks = undefined;
          }
        }
        this._endLoadingStatus();
      },


      _applyDurationDisplay: function(osd){
        var result = [];
        // Push the categories
        result.push([osd[0][0]]);
        for(var i = 1; i < osd[0].length; i++){
          result[0].push(osd[0][i]);
          result[0].push({ role: 'tooltip' });
        }
        // Push the values and their tooltip
        for(var i = 1; i < osd.length; i++){
          result.push([osd[i][0]]);
          for(var j = 1; j< osd[i].length; j++ ){
            result[i].push(osd[i][j]);
            result[i].push(this._ttu.get_human_rounded_duration(osd[i][j]));
          }
        }
        // Return reulst
        return result;
      },

      _setTicks: function(target){
        target = target || this;
        // Apply ticks display.
        var ticks = this._ttu.get_human_rounded_ticks(this._maxValue, 5);
        if( target.chartOptions.vAxis ) target.chartOptions.vAxis.ticks = ticks;
        else                            target.chartOptions.vAxis = {'ticks': ticks};
      },

      /** ================================================================== **/
      /**  OFFSPRING PROCESS                                                 **/

      /**
       * Sum the offsprings values to display in the main one.
       *
       * @method _getSumOffspringsDatas
       */
      _getSumOffspringsDatas: function() {
        // The result Array
        var sd = [
          ['interval']
        ];
        // The raw datas Arrays
        var od = this._offspringsDatas;
        var i, j, k, l, exists;
        var s = 0;
        // Some offsprings might have no datas, so we have to skip them.
        while (od[s] === null || od[s] === undefined) {
          s++;
        }
        // We push the categories names in the first line of the stacked datas.
        for (j = 1; j < od[s][0].length; j++) {
          sd[0].push(od[s][0][j]);
        }
        // Then we push the values In the stacked datas for the first serie.
        for (j = 1; j < od[s].length; j++) {
          sd.push([od[s][j][0]]);
          for (k = 1; k < od[s][j].length; k++) {
            sd[j].push((od[s][j][k] === null) ? 0 : od[s][j][k]);
          }
        }
        // Now, we fille the stacked datas for the rest of the series.
        for (i = s + 1; i < od.length; i++) {
          // Some offsprings still might have no data.
          if(od[i] !== null && od[i] !== undefined){
            // Check the titles
            var map = [null];
            // We look for the current category in the already registered ones (sd[0]).
            // If the category already exists (sd[0][k === od[i][0][j]]), we push it's position in 'map'
            // Otherwise, we add the category in sd[0]
            for (j = 1; j < od[i][0].length; j++) {
              exists = false;
              for (k = 0; k < sd[0].length; k++) {
                if (sd[0][k] === od[i][0][j]) {
                  exists = true;
                  map.push(k);
                  break;
                }
              }
              if (!exists) {
                sd[0].push(od[i][0][j]);
                for (l = 1; l < sd.length; l++) {
                  sd[l].push(0);
                }
                map.push(sd[0].length - 1);
              }
            }
            // We add the current offspring value to the existing one.
            for (j = 1; j < od[i].length; j++) {
              for (k = 1; k < od[i][j].length; k++) {
                sd[j][map[k]] = sd[j][map[k]] + ((od[i][j][k] === null) ? 0 : od[i][j][k]);
              }
            }
          }
        }
        return sd;
      },

      /**
       * Stack the raw datas for each offspring.
       *
       * @method _processRequestResultsForOffsprings
       */
      _processRequestResultsForOffsprings: function(rd) {
        var rd_index = 0;
        var data = [];
        var o_current = "";
        var o_index = 0;

        // The stacked_datas. The last one element is for the root histo.
        var stacked_datas_per_offspring = new Array(this.offsprings.length);
        // We go through the raw datas.
        while (rd_index < rd.length) {
          // Here we define the new offspring raw_datas.
          if (o_current === "") {
            o_current = rd[rd_index].ofs.value;
            o_index = this._findOffspringWithConstraint(o_current);
          }
          // Here we fill `data` as long as we stay on the same offspring.
          // And when we finished the offspring datas, We get the stacked datas.
          if (rd[rd_index].ofs.value === o_current) {
            data.push(rd[rd_index]);
          } else {
            if (o_index === -1) {
              stacked_datas_per_offspring[stacked_datas_per_offspring.length - 1] = this._orderStackedDatas(this._getStackedData(data));
            } else {
              stacked_datas_per_offspring[o_index] = this._orderStackedDatas(this._getStackedData(data));
            }
            data = [];
            o_current = "";
            rd_index--;
          }
          // When it's finally over, we fill the last stacked_datas.
          if (rd_index === (rd.length - 1)) {
            if (o_index === -1) {
              stacked_datas_per_offspring[stacked_datas_per_offspring.length - 1] = this._orderStackedDatas(this._getStackedData(data));
            } else {
              stacked_datas_per_offspring[o_index] = this._orderStackedDatas(this._getStackedData(data));
            }
          }
          rd_index++;
        }

        // If duration is checked
        if(this.$.durationCheck.checked){
          for(var i = 0; i < stacked_datas_per_offspring.length; i++){
            stacked_datas_per_offspring[i] = this._applyDurationDisplay(stacked_datas_per_offspring[i]);
          }
        }

        this.set('_offspringsDatas', stacked_datas_per_offspring);
      },


      _fillCharts: function() {
        for (var i = 0; i < this.offsprings.length; i++) {
          if (this._offspringsDatas[i] === null || this._offspringsDatas[i] === undefined) {
            this.offsprings[i][1].resetChart();
          } else {
            this.offsprings[i][1].setData(this._offspringsDatas[i]);
            this.offsprings[i][1].setMaxValue(this._maxValue);
            if(this.$.durationCheck.checked){
              this._setTicks(this.offsprings[i][1]);
            }
          }
        }
        this.$.chart.set('data', this._offspringsDatas[i]);
        this.setMaxValue(this._maxValue);
      },

      setMaxValue: function(val) {
        if (this.chartOptions.vAxis) {
          this.chartOptions.vAxis.maxValue = val;
        } else {
          this.chartOptions.vAxis = {
            'maxValue': val
          };
        }
      },

      setSeriesColor: function(colors) {
        this.chartOptions.series = colors;
      },

      _findOffspringWithConstraint: function(c) {
        var j = 0;
        while (j < this.offsprings.length) {
          if (c === this.offsprings[j][0].replace(/\"/g, '')) return j;
          j++;
        }
      },

      _setColors: function() {
        var d, s, i, j, color_index;
        for (i = 0; i < this._offspringsDatas.length; i++) {
          d = this._offspringsDatas[i];
          if (d) {
            s = [];
            for (j = 1; j < d[0].length; j++) {
              if (this._colorsMap[d[0][j]]) {
                s.push({
                  'color': this._colorsMap[d[0][j]]
                });
              } else {
                color_index = Object.keys(this._colorsMap).length % this._colors.length;
                this._colorsMap[d[0][j]] = this._colors[color_index];
                s.push({
                  'color': this._colorsMap[d[0][j]]
                });
              }
            }
            this.offsprings[i][1].setSeriesColor(s);
          }
        }
        // d = this._offspringsDatas[i];
        // s = [];
        // for (j = 1; j < d[0].length; j++) {
        //   if (this._colorsMap[d[0][j]]) {
        //     s.push({
        //       'color': this._colorsMap[d[0][j]]
        //     });
        //   } else {
        //     color_index = Object.keys(this._colorsMap).length % this._colors.length;
        //     this._colorsMap[d[0][j]] = this._colors[color_index];
        //     s.push({
        //       'color': this._colorsMap[d[0][j]]
        //     });
        //   }
        // }
        // this.setSeriesColor(s);
      },

      /**
       * Init and fill the chart.
       *
       * @method _setChart
       */
      _setChart: function() {

        this.set('_colorsMap', {});
        this.set('_offspringsDatas', []);
        this.set('_maxValue', Number.NEGATIVE_INFINITY);

        // Set the variables
        var period = this._periodMapping[this._periodIndex];
        var request = this._createRequest(period);
        this.trace.post_query(request).then(function(response) {
          this._processRequestResults(response.results.bindings);
        }.bind(this)).catch(function(err) {
          console.log(err);
        });

      },

      _orderStackedDatas: function(sd) {
        var nsd = [];
        var title = sd[0].slice(1);

        title.sort();

        var map = [];
        for (var i = 0; i < title.length; i++) {
          for (var j = 1; j < sd[0].length; j++) {
            if (title[i] === sd[0][j]) map.push(j);
          }
        }
        nsd.push([sd[0][0]]);
        for (var i = 0; i < title.length; i++) {
          nsd[0].push(title[i]);
        }
        for (var i = 1; i < sd.length; i++) {
          nsd.push([sd[i][0]]);
          for (var j = 0; j < title.length; j++) {
            nsd[i].push(sd[i][map[j]]);
          }
        }
        return nsd;
      },

      /**
       * Fill the chart.
       *
       * @method _fillChart
       */
      _fillChart: function(raw_datas) {
        this.$.chart.set('data', raw_datas);
        this.$.chart.redraw();
        // Stop the spinner
        this.$.spinner.active = false;
        this.$.spinnerContainer.style.display = 'none';
        // Able the apply button
        this.$.applyBtn.disabled = false;
      },

      _getStackedData: function(raw_datas) {
        // We init the 3 array that'll fill the charts.
        var stacked_datas = [
          ['interval']
        ];
        var type_names = [];

        // We init the different counters
        var i, currentPosition, totalCounts;
        i = currentPosition = totalCounts = 0;
        // We fill the data arrays. First loop is over the global datas.
        // Second loop is over the same interval in the global datas.
        while (i < raw_datas.length && currentPosition < this._timeline_interval_count) {
          // We create an array init to 0 for each type that exists.
          // This array correpond to one stacked column in the stacked chart.
          var _data_stacked_temp_ = [this._timeline_interval_names[currentPosition]];
          for (var type_pos = 1; type_pos < stacked_datas[0].length; type_pos++) {
            _data_stacked_temp_.push(null);
          }
          var sum = 0;
          // Now we loop inside the same interval to retrieve every obsel type count existing.
          // `Number(raw_datas[i].rangeId.value)` is the index of the interval. As long as it's the same, we're still in the same interval.
          while (i < raw_datas.length && Number(raw_datas[i].rangeId.value) === currentPosition) {
            // We look for the current obsel type count index in the stacked_data array
            // Then we set tis value.
            var exists = false;
            var type = null;
            var val = raw_datas[i].type.value.split('#')[1];
            if (val) type = raw_datas[i].type.value.split('#')[1];
            else type = raw_datas[i].type.value;

            var j = 0;
            for (j = 1; j < stacked_datas[0].length; j++) {
              if (type === stacked_datas[0][j]) {
                sum += Number(raw_datas[i].numMatches.value);
                _data_stacked_temp_[j] = Number(raw_datas[i].numMatches.value);

                exists = true;
              }
            }
            if (!exists) {
              stacked_datas[0].push(type);

              for (j = 1; j < stacked_datas.length; j++) {
                if (stacked_datas[j].length < stacked_datas[0].length) {
                  stacked_datas[j].push(null);
                }
              }
              sum += Number(raw_datas[i].numMatches.value);
              _data_stacked_temp_.push(Number(raw_datas[i].numMatches.value));
            }
            // Increment.
            i++;
          }
          if (sum > this._maxValue) this.set('_maxValue', sum);
          // We push the new entry of stacked_data (i.e. the count for each type of the current interval).
          stacked_datas.push(_data_stacked_temp_);
          // Increment.
          currentPosition++;
          totalCounts = 0;
        }
        for (var i = stacked_datas.length - 1; i < this._timeline_interval_count; i++) {
          var sd = [this._timeline_interval_names[i]];
          for (var j = 1; j < stacked_datas[0].length; j++) {
            sd.push(null);
          }
          stacked_datas.push(sd);
        }
        // We fill and draw the Charts.
        return stacked_datas;
      },

      /** ----------------------------------------------------------------------
      // MARK: Functions: Chart settings
      **/

      _setChartsTitle: function() {
        for (var i = 0; i < this.offsprings.length; i++) {
          if (this._offspringsDatas[i]) this._setChartTitle(i);
        }
        this._setChartTitle(null);
      },

      _setChartTitle: function(i) {
        var p = this._periodMapping[this._periodIndex];
        var t = (this._groupByIndex === 0 || this._groupByIndex === -1) ? "obsel type" : this._attributesList[this._groupByIndex - 1].name;
        var title = "Obsels distribution per " + p + " & per " + t;
        if (i !== null && i !== undefined) {
          title += " & " + this.constraint + " = " + this.offsprings[i][0];
          this.offsprings[i][1].setTitle(title);
        } else {
          this.setTitle(title);
        }

      },

      setTitle: function(title) {
        this.chartOptions.title = title;
      }

    });
  </script>
</dom-module>
